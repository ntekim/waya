// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payouts.sql

package db

import (
	"context"
	"database/sql"
)

const createPayout = `-- name: CreatePayout :one
INSERT INTO payouts (
  id, batch_id, reference_id, 
  recipient_name, recipient_phone, recipient_email, recipient_tag,
  country_code, bank_code, account_number, bank_name,
  amount, currency, status
) VALUES (
  ?, ?, ?, 
  ?, ?, ?, ?,
  ?, ?, ?, ?,
  ?, ?, ?
)
RETURNING id, batch_id, reference_id, recipient_name, recipient_phone, recipient_email, recipient_tag, country_code, bank_code, bank_name, account_number, amount, currency, status, error_message, created_at, updated_at
`

type CreatePayoutParams struct {
	ID             string         `json:"id"`
	BatchID        sql.NullString `json:"batch_id"`
	ReferenceID    string         `json:"reference_id"`
	RecipientName  string         `json:"recipient_name"`
	RecipientPhone string         `json:"recipient_phone"`
	RecipientEmail sql.NullString `json:"recipient_email"`
	RecipientTag   sql.NullString `json:"recipient_tag"`
	CountryCode    string         `json:"country_code"`
	BankCode       sql.NullString `json:"bank_code"`
	AccountNumber  sql.NullString `json:"account_number"`
	BankName       sql.NullString `json:"bank_name"`
	Amount         int64          `json:"amount"`
	Currency       string         `json:"currency"`
	Status         string         `json:"status"`
}

func (q *Queries) CreatePayout(ctx context.Context, arg CreatePayoutParams) (Payout, error) {
	row := q.queryRow(ctx, q.createPayoutStmt, createPayout,
		arg.ID,
		arg.BatchID,
		arg.ReferenceID,
		arg.RecipientName,
		arg.RecipientPhone,
		arg.RecipientEmail,
		arg.RecipientTag,
		arg.CountryCode,
		arg.BankCode,
		arg.AccountNumber,
		arg.BankName,
		arg.Amount,
		arg.Currency,
		arg.Status,
	)
	var i Payout
	err := row.Scan(
		&i.ID,
		&i.BatchID,
		&i.ReferenceID,
		&i.RecipientName,
		&i.RecipientPhone,
		&i.RecipientEmail,
		&i.RecipientTag,
		&i.CountryCode,
		&i.BankCode,
		&i.BankName,
		&i.AccountNumber,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPayout = `-- name: GetPayout :one
SELECT id, batch_id, reference_id, recipient_name, recipient_phone, recipient_email, recipient_tag, country_code, bank_code, bank_name, account_number, amount, currency, status, error_message, created_at, updated_at FROM payouts 
WHERE id = ? LIMIT 1
`

func (q *Queries) GetPayout(ctx context.Context, id string) (Payout, error) {
	row := q.queryRow(ctx, q.getPayoutStmt, getPayout, id)
	var i Payout
	err := row.Scan(
		&i.ID,
		&i.BatchID,
		&i.ReferenceID,
		&i.RecipientName,
		&i.RecipientPhone,
		&i.RecipientEmail,
		&i.RecipientTag,
		&i.CountryCode,
		&i.BankCode,
		&i.BankName,
		&i.AccountNumber,
		&i.Amount,
		&i.Currency,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listPayouts = `-- name: ListPayouts :many
SELECT id, batch_id, reference_id, recipient_name, recipient_phone, recipient_email, recipient_tag, country_code, bank_code, bank_name, account_number, amount, currency, status, error_message, created_at, updated_at FROM payouts 
ORDER BY created_at DESC
`

func (q *Queries) ListPayouts(ctx context.Context) ([]Payout, error) {
	rows, err := q.query(ctx, q.listPayoutsStmt, listPayouts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payout
	for rows.Next() {
		var i Payout
		if err := rows.Scan(
			&i.ID,
			&i.BatchID,
			&i.ReferenceID,
			&i.RecipientName,
			&i.RecipientPhone,
			&i.RecipientEmail,
			&i.RecipientTag,
			&i.CountryCode,
			&i.BankCode,
			&i.BankName,
			&i.AccountNumber,
			&i.Amount,
			&i.Currency,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPayoutsByBatchID = `-- name: ListPayoutsByBatchID :many
SELECT id, batch_id, reference_id, recipient_name, recipient_phone, recipient_email, recipient_tag, country_code, bank_code, bank_name, account_number, amount, currency, status, error_message, created_at, updated_at FROM payouts 
WHERE batch_id = ?
ORDER BY created_at DESC
`

func (q *Queries) ListPayoutsByBatchID(ctx context.Context, batchID sql.NullString) ([]Payout, error) {
	rows, err := q.query(ctx, nil, listPayoutsByBatchID, batchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payout
	for rows.Next() {
		var i Payout
		if err := rows.Scan(
			&i.ID,
			&i.BatchID,
			&i.ReferenceID,
			&i.RecipientName,
			&i.RecipientPhone,
			&i.RecipientEmail,
			&i.RecipientTag,
			&i.CountryCode,
			&i.BankCode,
			&i.BankName,
			&i.AccountNumber,
			&i.Amount,
			&i.Currency,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePayoutStatus = `-- name: UpdatePayoutStatus :exec
UPDATE payouts 
SET status = ?, error_message = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdatePayoutStatusParams struct {
	Status       string         `json:"status"`
	ErrorMessage sql.NullString `json:"error_message"`
	ID           string         `json:"id"`
}

func (q *Queries) UpdatePayoutStatus(ctx context.Context, arg UpdatePayoutStatusParams) error {
	_, err := q.exec(ctx, q.updatePayoutStatusStmt, updatePayoutStatus, arg.Status, arg.ErrorMessage, arg.ID)
	return err
}
